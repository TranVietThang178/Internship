/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f401re_rcc.h>
#include <stm32f401re_gpio.h>
#include <stm32f401re_tim.h>
#include <misc.h>

void Input_Capture(void);
void TIM2_IRQHandler(void);
static void Check_Tim_Press(void);
void Send_NumberPress(void);

uint16_t Tim_Rising = 0;
uint16_t Tim_Update = 0;
uint16_t Tim_SendData = 0;
uint16_t TimLimit_SendData = 0;
uint8_t Number_Press = 0;
static uint8_t Status1 = 0;

int main(void)
{
	Input_Capture();
	while(1)
	{
		Check_Tim_Press();
		Send_NumberPress();
	}
}

void Input_Capture(void)
{
	GPIO_InitTypeDef 			GPIO_InitStructure;
	TIM_TimeBaseInitTypeDef 	TIM_TimeBaseStructure;
	TIM_ICInitTypeDef			TIM_ICInitStructure;
	NVIC_InitTypeDef 			NVIC_InitStructure;

	//GPIO clock enable
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;

	GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_TIM2);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	//TIM2 Clock enable
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
	TIM_TimeBaseStructure.TIM_Prescaler = 41999;
	TIM_TimeBaseStructure.TIM_Period = 0xFFFF;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);

	//configure Input Capture
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;
	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_BothEdge;
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
	TIM_ICInitStructure.TIM_ICFilter = 0x0;

	TIM_ICInit(TIM2, &TIM_ICInitStructure);

	TIM_Cmd(TIM2, ENABLE);


	//Configure Input Capture Interrupt
	TIM_ITConfig(TIM2, TIM_IT_CC2, ENABLE);

	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
}

void TIM2_IRQHandler(void)
{
    if (TIM_GetITStatus(TIM2, TIM_IT_CC2) != RESET)
    {
        // Clear the TIM2 Capture Compare 2 interrupt flag
        TIM_ClearITPendingBit(TIM2, TIM_IT_CC2);

        // Check and handle button press
        Check_Tim_Press();
    }
}

static void Check_Tim_Press(void)
{
	uint8_t Number_Press = 0;

	Status1 = !Status1;

	if (Status1 == 1)
	{
		Number_Press++;
	}
	else if (Status1 == 0)
	{
		Tim_Rising = TIM_GetCapture2(TIM2);
		Status1 = 1;
	}
}

void Send_NumberPress(void)
{
    if (Status1 == 1)
    {
        if (Tim_Update < Tim_Rising)
        {
            Tim_SendData = (0xFFFF + Tim_Update) - Tim_Rising;
        }
        else
        {
            Tim_SendData = Tim_Update - Tim_Rising;
        }

        if (Tim_SendData >= TimLimit_SendData)
        {
            // Send the Number_Press value to the computer or perform other actions
            // Reset the counter and any other necessary variables
            Number_Press = 0;
            Tim_Rising = 0;
        }
    }
}
